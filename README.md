# 线程管理
## 线程管理的基础
        每一个程序都至少有一个线程：执行main()函数的线程，其余线程有各自的入口函数。线程与原始线程同时运行。如同main()函数执行完会退出一样，当线程执行完入口函数后，线程也会退出。在为一个线程创建了一个std::thread对象后，需要等待这个线程结束；不过，线程需要先进行启动。  
### 启动线程
        使用std::thread对象，可以创建一个线程，通常给它传递一个无参无返回值的函数。创建完成之后，改函数就会在其所在的线程上面执行，直到该函数执行完毕，该线程也就结束。  
### 线程控制
        在创建了一个线程之后，我们需要确定，是要等待线程结束(join)还是让线程自主运行(detach)，如果在std::thread销毁之前还没有做出决定，~std::thread就会调用std::terminate()结束程序。  
#### 等待线程完成
        可以通过join()来等待线程执行完成，如果子线程正在使用一些局部变量，那么我们可以使用join()来等待子线程执行完毕，这样就不会出现子线程还在执行，但是局部变量已经被销毁的情况了。  
####  后台运行线程
        使用detach()可以使线程在后台运行，即使主线程已经结束，这就意味着主线程不能与之产生直接交互。也就是说，不会等待这个线程结束；如果线程分离，那么就不可能有std::thread对象能引用它，分离线程的确在后台运行，所以分离线程不能被加入。  

####  识别线程  
        每一个线程都对应一个唯一标识符std::thread::id，可以通过两种方式获取线程id，第一种是通过std::thread对象的成员函数get_id()来直接获取。如果std::thread对象没有与任何执行线程相关联，get_id()将返回std::thread::type默认构造，这个值表示“没有线程”。第二种方式是在线程里面调用std::this_thread::get_id()来获取线程id。  
## 线程间共享数据  
### 共享数据带来的问题 
        当涉及到共享数据时，问题很可能是因为共享数据修改所导致的。如果共享数据是只读的，那么只读操作不会影响到数据，更不会涉及对数据的修改，所以所有线程都会获得同样的数据。但是，当一个或多个线程要修改共享数据时，就会产生很多麻烦。这种情况下，就必须小心谨慎，才能确保一切线程都工作正常。
### 使用互斥量来保护数据 
        当程序中有共享数据，肯定不想让其陷入条件竞争，或是不变量被破坏。那么，将所有访问共享数据结构的代码都标记为互斥岂不是更好？这样任何一个线程在执行这些代码时，其他任何线程试图访问共享数据结构，就必须等到那一段代码执行结束。于是，一个线程就不可能会看到被破坏的不变量，除非它本身就是修改共享数据的线程。
#### 死锁 
        一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。这样没有线程能工作，因为他们都在等待对方释放互斥量。这种情况就是死锁，它的最大问题就是由两个或两个以上的互斥量来锁定一个操作。
        避免死锁的办法：有顺序的对互斥量上锁、避免嵌套锁
### 数据保护的替代方案